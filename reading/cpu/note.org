#+DATE: <2025-06-16 Mon>
#+STARTUP: content

* note

<2025-06-16 Mon>

[[https://bookmeter.com/books/18368494][RISC-VとChiselで学ぶ はじめてのCPU自作 ――オープンソース命令セットによるカスタムCPU実装への第一歩]]

pp. 60

src_shell{git clone https://github.com/freechipsproject/chisel-template}

RISC-VのCPUを作る。

<2025-07-08 Tue 09:10>

# 表紙の印刷が凝ってる

pp. 61

#+NAME: dockerfile
#+begin_src dockerfile :tangle ./dockerfile
FROM ubuntu:18.04

ENV RISCV=/opt/riscv
ENV PATH=$RISCV/bin:$PATH
ENV MAKEFLAGS=-j4

WORKDIR $RISCV

RUN apt update && \
apt install -y autoconf automake autotools-dev
 curl libmpc-dev libmpfr-dev libgmp-dev gawk
 build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev
 pkg-config git libuseb-1.0-0-dev device-tree-compiler default-jdk gnupg vim

RUN gi clone -b rvv-0.9.x --single-branch https://github.com/riscv/riscv-gnu-toolchain.git && \
cd riscv-gnu-toolchain && git checkout 5842fde8ee5bb3371643b60ed34906eff7a5fa31 && \
git submodule update --init --recursive

RUN cd riscv-gnu-toolchain && mkdir build && cd build && ../configure --prefix=${RISCV} --enable-multilib && make

RUN git cline -b master --single-branch https://github.com/riscv/riscv-tests && \
cd riscv-tests && git checkout c4217d88bce9f805a81f42e86ff56ed363931d69 && \
git submodule update --init --recursive

RUN echo "deb https://repo.scala-sbt.org/scalasbt/debian all main" | tee -a /etc/apt/sources.list.d/sbt.list && \
echo "deb https://repo.scala-sbt.org/scalasbt/debian /" | tee /etc/apt/sources.list.d/sbt_old.list && \
curl -sL "https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823" | apt-key add && \
apt-get update && apt-get install -y sbt
#+end_src

#+begin_src shell
  docker build . -t riscv/mycpu
#+end_src

#+begin_quote
環境によっては2時間以上かかる場合もあります
#+end_quote

# えっ...

#+begin_src shell
  docker run -it -v $pwd:/src riscv/mycpu
#+end_src

pp. 63

#+NAME: Instructions.scala
#+begin_src java :tangle ./chisel-template/src/main/scala/common/Instructions.scala :mkdirp yes
  package common
      import chisel3._
      import chisel3.util._

      object Instructions {
	  /* ロード・ストア */
	  val LW      = BitPat("b??????????????????010?????0000011")
	  val SW      = BitPat("b??????????????????010?????0100011")

	  /* 加算 */
	  val ADD     = BitPat("b0000000???????????000?????0110011")
	  val ADDI    = BitPat("b??????????????????000?????0010011")

	  /* 減算 */
	  val SUB     = BitPat("b0100000???????????010?????0100011")

	  /* 論理演算 */
	  val AND     = BitPat("b0000000???????????111?????0110011")
	  val OR      = BitPat("b0000000???????????110?????0110011")
	  val XOR     = BitPat("b0000000???????????100?????0110011")
	  val ANDI    = BitPat("b??????????????????111?????0010011")
	  val ORI     = BitPat("b??????????????????110?????0010011")
	  val XORI    = BitPat("b??????????????????100?????0010011")

	  /* シフト */
	  val SLL     = BitPat("b0000000???????????001?????0110011")
	  val SRL     = BitPat("b0000000???????????101?????0110011")
	  val SRA     = BitPat("b0100000???????????101?????0110011")
	  val SLLI    = BitPat("b0000000???????????001?????0010011")
	  val SRLI    = BitPat("b0000000???????????101?????0010011")
	  val SRAI    = BitPat("b0100000???????????101?????0010011")

	  /* 比較 */
	  val SLT     = BitPat("b0000000???????????010?????0110011")
	  val SLTU    = BitPat("b0000000???????????011?????0110011")
	  val SLTI    = BitPat("b??????????????????010?????0010011")
	  val SLTIU   = BitPat("b??????????????????101?????0010011")

	  /* 条件分岐 */
	  val BEQ     = BitPat("b??????????????????000?????1100011")
	  val BNE     = BitPat("b??????????????????001?????1100011")
	  val BLT     = BitPat("b??????????????????100?????1100011")
	  val BGE     = BitPat("b??????????????????101?????0010011")
	  val BLTU    = BitPat("b??????????????????110?????1100011")
	  val BGEU    = BitPat("b??????????????????111?????1100011")

	  /* ジャンプ */
	  val JAL     = BitPat("b??????????????????????????1101111")
	  val JALR    = BitPat("b??????????????????000?????1100111")

	  /* 即値ロード */
	  val LUI     = BitPat("b??????????????????????????0110111")
	  val AUIPC   = BitPat("b??????????????????????????0010111")

	  /* CSR */
	  val CSRRW   = BitPat("b??????????????????001?????1110011")
	  val CSRRWI  = BitPat("b??????????????????101?????1110011")
	  val CSRRS   = BitPat("b??????????????????010?????1110011")
	  val CSRRSI  = BitPat("b??????????????????110?????1110011")
	  val CSRRC   = BitPat("b??????????????????011?????1110011")
	  val CSRRCI  = BitPat("b??????????????????111?????1110011")

	  /* 例外 */
	  val ECALL   = BitPat("b000000000000000000000000001110011")

	  /* ベクトル */
	  val VSETVLI = BitPat("b??????????????????111?????1010111")
	  val VLE     = BitPat("b000000100000??????????????0000111")
    	  val VSE     = BitPat("b000000100000??????????????0100111")
	  val VADDVV  = BitPat("b0000001???????????111?????1110011")

	  /* カスタム */
	  val PCNT    = BitPat("b000000000000??????110?????0001011")
	      }
#+end_src

<2025-07-11 Fri 18:46>

#+NAME: Consts.scala
#+begin_src java :tangle ./chisel-template/src/main/scala/common/Consts.scala :mkdirp yes
  package common
    import chisel3._
    import chisel3.util._

      object Consts {
      val WORD_LEN = 32
	  val START_ADDR = 0.u(WORD_LEN.W)
	  val BUBBLE     = 0x00000013.U(WORD_LEN.W)
	  val UNIMP      = 0xc0001073L.U(WORD_LEN.W)
	  val ADDR_LEN   = 5
	  val CSR_ADDR_LEN = 12
	  val VLEN         = 128
	  val LMUL_LEN     = 2
	  val SEW_LEN      = 11
	  val VL_ADDR      = 0xC20
	  val VTYPE_ADDR   = 0xC21

	  val EXE_FUN_LEN  = 5
	  val ALU_X        = 0.U(EXE_FUN_LEN.W)
	  val ALU_ADD      = 1.U(EXE_FUN_LEN.W)
	  val ALU_SUB      = 2.U(EXE_FUN_LEN.W)
	  val ALU_AND      = 3.U(EXE_FUN_LEN.W)
	  val ALU_OR       = 4.U(EXE_FUN_LEN.W)
	  val ALU_XOR      = 5.U(EXE_FUN_LEN.W)
	  val ALU_SLL      = 6.U(EXE_FUN_LEN.W)
	  val ALU_SRL      = 7.U(EXE_FUN_LEN.W)
	  val ALU_SRA      = 8.U(EXE_FUN_LEN.W)
	  val ALU_SLT      = 9.U(EXE_FUN_LEN.W)
	  val ALU_SLTU     = 10.U(EXE_FUN_LEN.W)
	  val BR_BEQ       = 11.U(EXE_FUN_LEN.W)
	  val BR_BNE       = 12.U(EXE_FUN_LEN.W)
	  val BR_BLT       = 13.U(EXE_FUN_LEN.W)
	  val BR_BGE       = 14.U(EXE_FUN_LEN.W)
	  val BR_BLTU      = 15.U(EXE_FUN_LEN.W)
	  val BR_BGEU      = 16.U(EXE_FUN_LEN.W)
	  val ALU_JALR     = 17.U(EXE_FUN_LEN.W)
	  val ALU_COPY1    = 18.U(EXE_FUN_LEN.W)
	  val ALU_VADDVV   = 19.U(EXE_FUN_LEN.W)
	  val VSET         = 20.U(EXE_FUN_LEN.W)
	  val ALU_PCNT     = 21.U(EXE_FUN_LEN.W)

	  val OP1_LEN      = 2
	  val OP1_RS1      = 0.U(OP1_LEN.W)
	  val OP1_PC       = 1.U(OP1_LEN.W)
	  val OP1_X        = 2.U(OP1_LEN.W)
	  val OP1_IMZ      = 3.U(OP1_LEN.W)

	  val OP2_LEN      = 3
	  val OP2_X        = 0.U(OP2_LEN.W)
	  val OP2_RS2      = 1.U(OP2_LEN.W)
	  val OP2_IMI      = 2.U(OP2_LEN.W)
	  val OP2_IMS      = 3.U(OP1_LEN.W)
	  val OP2_IMJ      = 4.U(OP2_LEN.W)
	  val OP2_IMU      = 5.U(OP1_LEN.W)

	  val MEN_LEN      = 2
	  val MEN_X        = 0.U(MEN_LEN.W)
	  val MEN_S        = 1.U(MEN_LEN.W)
	  val MEN_V        = 2.U(MEN_LEN.W)

	  val REN_LEN      = 2
	  val REN_X        = 0.U(REN_LEN.W)
	  val REN_S        = 1.U(REN_LEN.W)
	  val REN_V        = 2.U(REN_LEN.W)

	  val WB_SEL_LEN   = 3
	  val WB_X         = 0.U(WB_SEL_LEN.W)
	  val WB_ALU       = 0.U(WB_SEL_LEN.W)
	  val WB_MEM       = 1.U(WB_SEL_LEN.W)
	  val WB_PC        = 2.U(WB_SEL_LEN.W)
	  val WB_CSR       = 3.U(WB_SEL_LEN.W)
	  val WB_MEM_V     = 4.U(WB_SEL_LEN.W)
	  val WB_ALU_V     = 5.U(WB_SEL_LEN.W)
	  val WB_VL        = 6.U(WB_SEL_LEN.W)

	  val MW_LEN       = 3
	  val MW_X         = 0.U(MW_LEN.W)
	  val MW_W         = 1.U(MW_LEN.W)
	  val MW_H         = 2.U(MW_LEN.W)
	  val MW_B         = 3.U(MW_LEN.W)
	  val MW_HU        = 4.U(MW_LEN.W)
	  val MW_BU        = 5.U(MW_LEN.W)

	  val CSR_LEN      = 3
	  val CSR_X        = 0.U(CSR_LEN.W)
	  val CSR_W        = 1.U(CSR_LEN.W)
	  val CSR_S        = 2.U(CSR_LEN.W)
	  val CSR_C        = 3.U(CSR_LEN.W)
	  val CSR_E        = 4.U(CSR_LEN.W)
	  val CSR_V        = 5.U(CSR_LEN.W)
	  }
#+end_src
